#include <unordered_map>
#include <vector>
#include <iostream>
#include <iomanip>

template <class TGraph, class TArc>
void PAffichage<TGraph, TArc>::AFFAfficheSommetsEtArcs(TGraph& TGraphAFFGraphe)
{
    vector<PSommet<TArc>*> vSommet = TGraphAFFGraphe.GORGetSommet();
    vector<TArc*> vArc = TGraphAFFGraphe.GORGetArc();
    size_t stSizevArc = vArc.size();
        
    printf("Voici la liste des sommets du graphe :\n");

    //Si le type n'est pas un graphe, le getter ne sera pas trouvé
    if (vSommet.empty()) 
    {
        throw logic_error("Le graphe ne contient aucun sommet");
    }
    if (vArc.empty()) 
    {
        throw logic_error("Le graphe ne contient aucun arc");
    }
    size_t stSizevSommet = vSommet.size();
    for (size_t stIndex = 0; stIndex < stSizevSommet; stIndex++)
    {
        cout << vSommet[stIndex]->SOMGetNumero() << "\n" << endl;
    }
    cout << "Voici la liste des arcs du graphe, chaque arc est represente par son sommet de depart et son sommet d'arrivee : \n" << endl;
	//Dans le cas d'un graphe non oriente, il existera un arc allant du sommet de depart a celui d'arrivee et un allant du sommet d'arrivee a celui de depart
    for (size_t stIndex = 0; stIndex < stSizevArc; stIndex++)
    {
        cout << "Arc" << stIndex << " : " 
        << vArc[stIndex]->ARCGetNumeroD() << " -> " 
        << vArc[stIndex]->ARCGetNumeroA() << "\n" << endl;
    }
}

template <class TGraph, class TArc>
void PAffichage<TGraph, TArc>::AFFAfficheMatriceAdjacence(TGraph& TGraphAFFGraphe)
{
	//On récupère les vecteurs contenant les listes d'arcs et de sommets
	vector<TArc*> vArc = TGraphAFFGraphe.GORGetArc();
	vector<PSommet<TArc>*> vSommet = TGraphAFFGraphe.GORGetSommet();
	size_t stNbLignesColonnes = vSommet.size();
	//Si stNbLignesColonnes n'a pas été créé c'est que le type passe n'est pas un type graphe et le getter ne sera pas trouvé
	if (vSommet.empty()) {
		throw logic_error("Le graphe ne contient aucun sommet");
	}
	if (vArc.empty()) {
		throw logic_error("Le graphe ne contient aucun arc");
	}

	//On associe un index à un numéro de sommet dans la matrice, 
	//afin que les numéros de sommets puissent être différents des index de colonnes de la matric
	unordered_map<unsigned int, int> unIndexMap;
	for (int stIndex = 0; stIndex < stNbLignesColonnes; ++stIndex) {
		unIndexMap[vSommet[stIndex]->SOMGetNumero()] = stIndex;
	}	

	//On remplit la matrice de 0, et on met des 1 la ou il y a bien un arc entre les sommets
	vector<vector<unsigned int>> vvuiMatrice(stNbLignesColonnes, vector<unsigned int>(stNbLignesColonnes, 0));
	for (size_t stIndex = 0; stIndex < vArc.size(); ++stIndex) {
		TArc* TArcArc = vArc[stIndex];
		size_t stIndexLigne = unIndexMap[TArcArc->ARCGetNumeroD()];
		size_t stIndexColonne = unIndexMap[TArcArc->ARCGetNumeroA()];
		vvuiMatrice[stIndexLigne][stIndexColonne] = 1;
	}

	//Affichage console de la matrice
	cout << "\n    ";

	for (PSommet<TArc>* sommet : vSommet)
	{
		cout << setw(4) << sommet->SOMGetNumero();
	}

	cout << "\n    ";

	for (int i = 0; i < stNbLignesColonnes; ++i)
	{
		cout << "----";
	}

	cout << "\n";

	for (int i = 0; i < stNbLignesColonnes; ++i)
	{
		cout << setw(3) << vSommet[i]->SOMGetNumero() << "|";
		for (int j = 0; j < stNbLignesColonnes; ++j)
		{
			cout << setw(4) << vvuiMatrice[i][j];
		}
		cout << "\n";
	}
}