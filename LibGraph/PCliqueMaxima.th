template<class TArc>
PClique_max<TArc>::PClique_max()
{
    stTailleMaxClique = 0;
}

template<class TArc>
PClique_max<TArc>::~PClique_max()
{
	CLIResetCliqueMax();
}

template<class TArc>
vector<vector<PSommet<TArc>*>> PClique_max<TArc>::CLIGetVvCliquesMax()
{
    return vvCliques_Max;
}

template<class TArc>
bool PClique_max<TArc>::CLIIsClique(vector<PSommet<TArc>*> CLIvSommets) {
    for (size_t i = 0; i < CLIvSommets.size(); i++) {
        for (size_t j = i + 1; j < CLIvSommets.size(); j++) {
            PSommet<TArc>* s1 = CLIvSommets[i];
            PSommet<TArc>* s2 = CLIvSommets[j];
            bool connected = false;

            //On vérifie si s1 est connecté à s2
            for (TArc* arc : s1->SOMGetArcD()) {
                if (arc->ARCGetNumeroA() == s2->SOMGetNumero()) {
                    connected = true;
                    break;
                }
            }

            //Sinon, on regarde si s2 est connecté à s1 (car graphe non orienté uniquement)
            if (!connected) {
                for (TArc* arc : s2->SOMGetArcD()) {
                    if (arc->ARCGetNumeroA() == s1->SOMGetNumero()) {
                        connected = true;
                        break;
                    }
                }
            }
            if (!connected) {
                return false;
            }
        }
    }
    return true;
}

template<class TArc>
void PClique_max<TArc>::CLIResetCliqueMax()
{
    stTailleMaxClique = 0;
    for (size_t stIterator = 0; stIterator < vvCliques_Max.size(); stIterator++)
    {
        vvCliques_Max[stIterator].clear();
    }
    vvCliques_Max.clear();
}

template<class TArc>
void PClique_max<TArc>::CLIEnuCliqueMax(PGraph<TArc> CLIGraph, vector<PSommet<TArc>*> CLIListeSommet)
{
    vector<PSommet<TArc>*> vListeSommet = CLIGraph.GORGetSommet();

    //Cas où il ne reste aucun sommet à test
    if (vListeSommet.empty())
    {
        if (CLIListeSommet.size() > stTailleMaxClique)
        {
            CLIResetCliqueMax();
            stTailleMaxClique = CLIListeSommet.size();
            vvCliques_Max.push_back(CLIListeSommet);
        }
        else if (CLIListeSommet.size() == stTailleMaxClique)
        {
            vvCliques_Max.push_back(CLIListeSommet);
        }
        return;
    }

    for (size_t i = 0; i < vListeSommet.size(); ++i)
    {
        PSommet<TArc>* pSommet = vListeSommet[i];

        //Booléen qui vérifie si ce sommet est compatible avec la clique candidate
        bool compatible = true;
        for (PSommet<TArc>* s : CLIListeSommet)
        {
            if (!s->SOMEstVoisinAvec(pSommet)) //Méthode implémentée dans PSommet
            {
                compatible = false;
                break;
            }
        }

        if (!compatible)
            continue;

        //On rajoute le sommet à la clique que l'on teste
        vector<PSommet<TArc>*> newClique = CLIListeSommet;
        newClique.push_back(pSommet);

        //On vérifie si les voisins de pSommet ne sont pas aussi dans vListeSommet
        vector<PSommet<TArc>*> newVListeSommet;
        for (size_t j = i + 1; j < vListeSommet.size(); ++j)
        {
            if (pSommet->SOMEstVoisinAvec(vListeSommet[j]))
                newVListeSommet.push_back(vListeSommet[j]);
        }

        //On crée le nouveau graphe avec les sommets compatibles restants
        PGraph<TArc> newGraph;
        newGraph.GORSetvGORPSommet(newVListeSommet);

        CLIEnuCliqueMax(newGraph, newClique);
    }
}




