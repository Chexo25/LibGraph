template<class TArc>
PClique_max<TArc>::PClique_max()
{
    stTailleMaxClique = 0;
}

template<class TArc>
PClique_max<TArc>::~PClique_max()
{
	CLIResetCliqueMax();
}

template<class TArc>
vector<vector<PSommet<TArc>*>> PClique_max<TArc>::CLIGetVvCliquesMax()
{
    return vvCliques_Max;
}

template<class TArc>
bool PClique_max<TArc>::CLIIsClique(vector<PSommet<TArc>*> CLIvSommets) {
    for (size_t i = 0; i < CLIvSommets.size(); i++) {
        for (size_t j = i + 1; j < CLIvSommets.size(); j++) {
            PSommet<TArc>* s1 = CLIvSommets[i];
            PSommet<TArc>* s2 = CLIvSommets[j];
            bool connected = false;

            //On vérifie si s1 est connecté à s2
            for (TArc* arc : s1->SOMGetArcD()) {
                if (arc->ARCGetNumeroA() == s2->SOMGetNumero()) {
                    connected = true;
                    break;
                }
            }

            //Sinon, on regarde si s2 est connecté à s1 (car graphe non orienté)
            if (!connected) {
                for (TArc* arc : s2->SOMGetArcD()) {
                    if (arc->ARCGetNumeroA() == s1->SOMGetNumero()) {
                        connected = true;
                        break;
                    }
                }
            }
            if (!connected) {
                return false;
            }
        }
    }
    return true;
}

template<class TArc>
void PClique_max<TArc>::CLIResetCliqueMax()
{
    stTailleMaxClique = 0;
    for (size_t stIterator = 0; stIterator < vvCliques_Max.size(); stIterator++)
    {
        vvCliques_Max[stIterator].clear();
    }
    vvCliques_Max.clear();
}

template<class TArc>
void PClique_max<TArc>::CLIEnuCliqueMax(PGraph<TArc> Graph, vector<PSommet<TArc>*> ListeSommet)
{
    vector<PSommet<TArc>*> vListeSommet = Graph.GORGetSommet();

    if (vListeSommet.size() == 0)
    {
        if (ListeSommet.size() > stTailleMaxClique)
        {
            CLIResetCliqueMax();
            stTailleMaxClique = ListeSommet.size();
            vvCliques_Max.push_back(ListeSommet);
        }
        else if (ListeSommet.size() == stTailleMaxClique)
        {
            vvCliques_Max.push_back(ListeSommet);
        }
        return;
    }

    for (size_t stIterator = 0; stIterator < vListeSommet.size(); stIterator++)
    {
        try {
            PSommet<TArc>* pSommet = vListeSommet[stIterator];

            PGraph<TArc> GraphCopy = Graph;

            vector<PSommet<TArc>*> ListeAvecSommet = ListeSommet;
            ListeAvecSommet.push_back(pSommet);

            GraphCopy.GORSupprimerSommet(pSommet);

            if (CLIIsClique(ListeAvecSommet))
            {
                CLIEnuCliqueMax(GraphCopy, ListeAvecSommet);
            }

            CLIEnuCliqueMax(GraphCopy, ListeSommet);
        }
        catch (const exception&) {
            continue;
        }
    }
}
